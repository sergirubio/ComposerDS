#    "$Name:  $";
#    "$Header:  $";
#=============================================================================
#
# file :        PyStateComposer.py
#
# description : Python source for the PyStateComposer and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PyStateComposer are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author: sergi_rubio $
#
# $Revision: 1.2 $
#
# $Log: PyStateComposer.py,v $
# Revision 1.2  2009/01/22 16:37:41  sergi_rubio
# Now this PyStateComposer uses Miscellaneous/PyTango_utils package. It provides DynamicDS and ThreadDict for DynamicAttributes and reliable polling.
#
# $Revision:  $
#
# Revision 1.1.1.1  2007/10/17 16:42:52  sergi_rubio
# A PyTango StateComposer, based on Calculation/StateComposer device
#
# copyleft :    ALBA Synchrotron
#               Barcelona, EU
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Controls Section - ALBA
#=============================================================================
#


import PyTango
import sys,os,time,traceback,re
import threading
import collections
from functools import partial
from copy import *
try: import fandango
except: import PyTango_utils as fandango

import fandango.functional as fun
from fandango import DynamicDS,DynamicDSClass,DynamicAttribute
from fandango.interface import FullTangoInheritance
from fandango.dynamic import CreateDynamicCommands,USE_STATIC_METHODS
from fandango.device import Dev4Tango,fakeEventType,get_matching_devices,get_database
from fandango.tango import fakeAttributeValue

from fandango import CaselessList

if "Device_4Impl" not in dir(PyTango):
    print 'Adapting to PyTango7 ...'
    PyTango.DeviceClass = PyTango.PyDeviceClass
    PyTango.Device_4Impl = PyTango.Device_3Impl
    
try: __RELEASE__ = (l for l in open(os.path.dirname(os.path.abspath(__file__))+'/CHANGES').readlines() if l.startswith('VERSION')).next().split('=',1)[-1].strip()
except Exception,e: __RELEASE__ = str(e)
print '> ',__RELEASE__

"""
@mainpage PyStateComposer Tango Device Server

"""


#==================================================================
#   PyStateComposer Class Description:
#
#         <p>This device requires <a href="http://www.tango-controls.org/Documents/tools/fandango/fandango">Fandango module<a> to be available in the PYTHONPATH.</p>
#         PyStateComposer(Dev4Tango,DynamicDS) allows to create a new composed State or Attributes using the State and Attributes from a list of devices: <ul>
#         <li>When a new Device is added the composer subscribes to its State changes.</li>
#         <li>If it is not able to subscribe to events, then a polling thread is started.</li>
#         <li>relays on PyTango_utils package to provide DynamicAttributes and DynamicStates.</li>
#         <li>Either StatePolicy or DynamicStates property can be used to compose the State.</li>
#         <li>StatePolicy uses the same format than Soleil's composer, the default policy is generated the first time the composer is launched</li>
#         </ul>
#
#==================================================================


class PyStateComposer(PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------
    '''   @class PyStateComposer
    PyStateComposer(Dev4Tango,DynamicDS) allows to create a new composed State or Attributes using the State and Attributes from a list of devices: <ul>
    <li>When a new Device is added the composer subscribes to its State changes.</li>
    <li>If it is not able to subscribe to events, then a polling thread is started.</li>
    <li>relays on PyTango_utils package to provide DynamicAttributes and DynamicStates.</li>
    <li>Either StatePolicy or DynamicStates property can be used to compose the State.</li>
    <li>StatePolicy uses the same format than Soleil's composer, the default policy is generated the first time the composer is launched</li>
    </ul>
    '''
    
    defaultStatePriorities = {
            'ON':0, 
            'OPEN':0, 
            'EXTRACT':0, 
            'STANDBY':0, 
            'MOVING':8, 
            'RUNNING':8, 
            'CLOSE':10, 
            'INSERT':10, 
            'DISABLE':11, 
            'OFF':11, 
            'UNKNOWN':12,
            'INIT':13, 
            'ALARM':13, 
            'FAULT':14, 
            }
    
    def cout(self,prio,s):
        if self.getLogLevel(prio)>=self.log_obj.level:
            print '%s %s %s: %s' % (prio.upper(),time.strftime('%Y-%m-%d %H:%M:%S',time.localtime()),self.get_name(),s)
        if hasattr(self,prio): getattr(self,prio)(s)

    def event_received(self,source,type_,attr_value):
        """
        This method manages the events received from external attributes.
        """
        self.last_event_received = time.time()
        DynamicDS.event_received(self,source,type_,attr_value)
        self.cout('info','-'*80)
        self.cout('info','In PyStateComposer.event_received(%s(%s),%s,%s)'%(type(source).__name__,source,fakeEventType[type_],type(attr_value).__name__))
        try:
            source = fandango.tango.get_model_name(source)
            self.cout('debug','source = %s'%source)
            if 'Config'==fakeEventType[type_]:
                self.cout('debug','Config event ignored ... %s'%source)
            elif '/' not in source:
                self.cout('info','Not-tango names ignored ... %s'%source)
            else:
                params = fandango.tango.parse_tango_model(source)
                if params:
                    tango_host,dev_name,att,attr_name = '%s:%s'%(params['host'],params['port']),\
                        params['devicename'],params['attributename'],'%s/%s'%(params['devicename'],params['attributename'])
                else: 
                    self.cout('error','Unparsable source: %s => %s'%(source,params))
                    tango_host,dev_name,att,attr_name = '','',None,''
                if 'Error'==fakeEventType[type_] or not hasattr(attr_value,'value'):
                    self.cout('warning','%s Error received: %s'%(attr_name,attr_value))
                    self.AttributeCache[attr_name] = fakeAttributeValue(attr_name,attr_value,time.time(),error=True)
                    value = None
                else:
                    self.AttributeCache[attr_name] = attr_value # I keep value/time/quality struct
                    value = attr_value.value
                if att == 'state' and (self.DevicesDict.get(dev_name)!=value or 'Error'==fakeEventType[type_]):
                    self.DevicesDict[dev_name] = fun.notNone(value,PyTango.DevState.UNKNOWN)
                    if self.__initialized: self.evaluateStates()
        except:
            self.cout('error','Exception in event_received(%s,%s,...):\n%s'%(source,type_,traceback.format_exc()))
        self.cout('info','Out of PyStateComposer.event_received()')
        return

    def updateSubComposers(self):
        #Updating _locals dictionary
        if hasattr(self,'SubComposers') and self.SubComposers:
            for composer in sorted(self.SubComposers):
                self.debug('Importing states from composer: %s ' % (composer))
                devs = self.getXAttr(composer+'/DevicesList')
                states = self.getXAttr(composer+'/StatesList')
                try:
                    self.SubComposers[composer].update(zip(devs,states))
                    [(self._locals['DEVICES'].append(k),self._locals['STATES'].append(v)) for k,v in sorted(zip(devs,states))]
                except:
                    self.error('Unable to import states from %s:\ndevs:%s\nstates:%s\n%s' % (composer,str(devs),str(states),traceback.format_exc()))
        return
                        
    def evaluateStates(self):
        '''
        This method is called from push_event, always_executed_hook, AddDeviceToList and RemoveDevice methods; It depends of UseEvents property.
        
        It iterates over DevicesDict/StatesList dictionary and:
        
        @li Chooses the highest priority in StatesList
        @li Makes a report with the epochs received for each dev in EventsList
        @li Makes a report with subscribed AttributesList
        @li Updates status and state and forces a push_change_event('state') 
        '''
        self.cout('debug','In evaluateStates(UseEvents=%s) ...'%self.UseEvents)
        dead_thread = 0
        now = time.time()
        states = []
        self.LastStateCheck = now
        new_state = old_state = self.get_state()
        try:
            #publishing Devices and States for Dynamic Attributes and States
            self._locals['DEVICES'] = CaselessList(self.DevicesDict.keys())
            if self.SortLists: self._locals['DEVICES'] = sorted(self._locals['DEVICES'])
            self._locals['STATES'] = [self.DevicesDict[k] for k in self._locals['DEVICES']]
            self._locals['IGNORED'] = []
            
            if not self.DevicesDict:
                self.cout('warning','DevicesDict is empty! State (%s) will not be updated.'%old_state)
            else:
                #Discarding devices in IgnoreList property
                self.IgnoreList = [a.lower() for a in self.IgnoreList if a.strip() and not a.startswith('#')]
                for k,v in self.DevicesDict.items():
                    if not fun.matchAny(self.IgnoreList,k.lower()):
                        states.append(v)
                        #Checking dead_threads
                        try:
                            a = (k+'/state').lower()
                            if a not in self.AttributeCache: self.AttributeCache[a] = fakeAttributeValue(a,None,0)
                            av = self.AttributeCache[a]
                            last = av.time.totime()
                            if (last-now)>(0.5e-3*self.PollingCycle):
                                print '>'*80
                                self.cout('info','Checking untracked %s changes since %s'%(a,last))
                                try: v = av.read(cache=False).value
                                except: v = None
                                if v!=av.value:
                                    dead_thread = last
                                    self.cout('error','*'*80)
                                    self.cout('error','%s THREAD IS DEAD SINCE %s (%s != %s) !'%(a.upper(),time.ctime(dead_thread),av.value,v))
                                    self.cout('error','*'*80)
                                if not isinstance(av,fakeAttributeValue):
                                    self.AttributeCache[a] = fakeAttributeValue(a,value,now,av.quality,av.dim_x,av.dim_y)
                                else:
                                    self.AttributeCache[a].set_date(now)
                        except:
                            #if not av:
                                #self.warning('%s error received or not read yet!')
                            #elif av.value not in (None,PyTango.DevState.UNKNOWN):
                            self.cout('error','Exception in evaluateStates(%s)'%a)
                            print traceback.format_exc()
                    else: self._locals['IGNORED'].append(k.lower())
            
            if not dead_thread:
                # To sort the values we use the priority for each state; obtained using the state name from self.TangoStates
                # The highest priority (last) will give the new_state
                if states:
                    new_state = sorted(states,key=lambda st:self.StatePriorities[str(st)])[-1]
                elif self.DevicesDict:
                    self.cout('warning','StatesList is empty!?!?!')
                    new_state = PyTango.DevState.UNKNOWN
                    
                if self.dyn_states:
                    result = '%s = %s\n' %(str(old_state),self.dyn_states.get(str(old_state),{}).get('formula',' ...' ))
                    self.cout('info','DynamicStates (%s) overrides State composing.'%result)                    
                elif states:
                    result = '%s = %s\n' % (str(new_state),'+'.join(sorted(set('%s(%d)'%(s,self.StatePriorities.get(str(s),0)) for s in states))))
                else:
                    result = '%s\n'%old_state
                    
                if new_state != old_state:
                    #@todo Some Hystheresis or change conditions must be applied before changing the State @n (e.g. keeping FAULT at least for 5 State evaluations, waiting 3 cycles before setting an UNKNOWN state)
                    self.LastStateUpdate = time.time()
                    if states: self.info(sorted(states,key=lambda st:self.StatePriorities[str(st)])[-1])
                    if not self.dyn_states:
                        self.cout('info','State changed! %s -> %s' % (old_state,new_state))
                        self.set_state(new_state)
                        self.push_change_event('state')                    
                
                status = '%s is in %s State since %s.\n'%(self.get_name(),self.get_state(),time.ctime(self.LastStateUpdate))
                status += 'DevicesList:\n'
                for dev,state in zip(self._locals['DEVICES'],self._locals['STATES']):
                    status += dev + ':\t' + str(state) + '\n'
                status = result+status+'\nLast Changes:\n'
                for d,h in self.History: status+='%s: %s'%(time.ctime(d),h)
                if not self.History or result!=self.History[0][1]: self.History.insert(0,(time.time(),result))
                self.History = self.History[:5]
                status+="\n\nLast event received at %s"%time.ctime(self.last_event_received)
                #Initializes local variables needed by DynamicStatus generation in DynamicDS.always_executed_hook
                if not self.DynamicStatus: self.set_status(status) 
                else: self._locals['STATUS'] = status
            else:
                self.set_state(PyTango.DevState.FAULT)
                self.set_status('DEAD THREAD!\nDevice should be restarted?')

            self.cout('debug','evaluateStates(): composer status = %s'%status)
            
        except Exception,e:
            msg = 'Exception in evaluateStates(): %s' % traceback.format_exc()
            self.cout('error',msg)
            self.set_status(msg)
         
        t3=time.time()
        self.cout('info','Out of evaluateStates() ... it took %f ms' % (1000.*(t3-now)))

            
    def create_state_attribute(self,argin):
        new_attr_name = argin.upper().replace('/','_')
        self.info('Creating attribute %s for %s/State' % (argin,new_attr_name))
        self.add_attribute(PyTango.Attr(new_attr_name,PyTango.ArgType.DevState,PyTango.AttrWriteType.READ),
                self.read_state_attribute,
                None, #self.write_new_attribute #(attr)
                lambda s,req_type,attr_name=argin: True,
                )

    def read_state_attribute(self,attr,attr_name=None):
        self.info('In read_state_attribute(%s,%s,%s)'%(self.get_name(),attr.get_name(),attr_name))
        if attr_name is None: 
            attr_name = [a.lower() for a in self.DevicesDict if a.replace('_','').replace('/','').lower()==attr.get_name().replace('_','').lower()]
            if not attr_name: raise Exception('%s:AttributesNotFound!'%attr.get_name())
        self.debug('\t%s = > %s'%(attr.get_name(),attr_name))
        attr.set_value(self.DevicesDict[((fun.isSequence(attr_name) and attr_name and attr_name[0]) or attr_name).lower()])
    if USE_STATIC_METHODS: read_state_attribute=staticmethod(read_state_attribute)
    
    def AddDeviceToList(self,argin):
        ''' @brief This method adds a new device to @bPyTango_utils.callback@b dictionaries: StatesList, EventsList, AttributesLIst ...
        @param[in] argin : the device to add; it must be an string; it can contain '*' or '?' , but not regular expressions
        
        Behaviour:
        @li the composer and the device are both added to DevicesDict (but composer itself cannot be added as device)
        @li A DeviceProxy is created for the device
        @li If needed: StatesList[dev_name] and AttributesList[dev_name] are initialized to UNKNOWN and None
        @li For State and each value in AttributesList keys it checks if appears in the list of attributes of the device
        
        For each cross-checked device attribute (or at least State attribute):
        @li if ForcePolling is set ... the polling of this attribute is forced
        @li A TAttr object is added to EventsList dictionary; it stores event receivers, DeviceProxy, event_id and more ...
        @li The composer is subscribed to the device attribute CHANGE events
        '''
        self.info("In AddDeviceToList(%s) ..." % str(argin))
        try:
            if '*' in argin or '?' in argin:
                devs = get_matching_devices(argin,fullname=False)
                self.info('AddDeviceToList: %d devices got from Database using wildcard (%s)'%(len(devs),argin))
                for d in devs:
                    self.AddDeviceToList(d)
            else:
                dev_name = (fun.isSequence(argin) and argin and argin[0] or argin).lower()
                assert '/' in dev_name,'%s is not a valid device name!'%dev_name
                assert dev_name!=self.get_name().lower(),"PyStateComposer doesn't allow recursive composing."
                try:
                    self.DevicesDict[dev_name] = PyTango.DevState.INIT
                    self.subscribe_external_attributes(dev_name,['State'])
                    self.create_state_attribute(argin)
                    return True
                except:
                    self.error('Unable to subscribe to %s: %s' % (argin,traceback.format_exc()))
        
        except Exception,e:
                self.error('Exception in AddDevice(): %s' % traceback.format_exc())

#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        self.call__init__(DynamicDS,cl,name,
            _locals={
                #'list': fun.toList,
                'join': fun.join,
                'taurus': fandango.tango.TAU or None,
                },
            useDynStates=True)
        self.__initialized = False
        PyStateComposer.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        if hasattr(self,'add_thread') and self.add_thread.is_alive():
          self.add_event.set()
          self.add_thread.join()
        self.info('*'*80)
        self.info("[Device delete_device method] for device %s"%self.get_name())
        #self.unsubscribe_external_attributes()
        self.info('*'*80)

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        print "In ", self.get_name(), "::init_device()"
        self._db = getattr(self,'_db',PyTango.Database())
        
        #Order Matters!
        #self.get_device_properties(self.get_device_class())
        try: DynamicDS.init_device(self)
        except: self.get_DynDS_properties()
        
        #self.setLogLevel(self.LogLevel if hasattr(self,'LogLevel') else 'INFO')
        self.set_state(PyTango.DevState.INIT)
        st = 'Connecting devices ... '
        self.set_status(st)
        # If self.DevicesList property is not initialized then DeviceNameList is read instead; this is for Soleil's device compatibility
        if not self.DevicesList:
            props = self._db.get_device_property(self.get_name(),['DeviceNameList','DevicesList'])
            if not props['DevicesList']: self.DevicesList = props['DeviceNameList']
        self.DeviceNameList = self.DevicesList
        self.IgnoreList = [a for a in self.IgnoreList if a.strip() and not a.startswith('#')]
        #self.info('DevicesList:%s'%self.DevicesList)
        #Updating StatePriorities dictionary
        self.UpdateStatePolicy(read_properties = False)
        
        if not self.__initialized:
            self.DevicesDict = fandango.SortedDict()#fandango.CaselessDict()
            self.AttributeCache = fandango.CaselessDict()
            self.History = []
            self.LastStateCheck = 0.
            self.LastStateUpdate = 0.
            self.last_event_received = 0.
            self.set_change_event('State',True,True)
            
            self.info('Updating Device Properties ...')
            default_props = {
                'UseEvents':self.UseEvents,
                'PollingCycle':[self.PollingCycle],
                } 
            if not len(self.DynamicStates): default_props['StatePolicy']=self.StatePolicy
            if not self.DevicesList: default_props['DeviceNameList']=self.DeviceNameList
            if not len(self.IgnoreList): default_props['IgnoreList']=['']
            
            self._db.put_device_property(self.get_name(),dict((k,(v if len(v) else None) if fun.isSequence(v) else [v]) for k,v in default_props.items()))
            self.info('DevicesList:%s'%self.DevicesList)
            self.info('IgnoreList:%s'%self.IgnoreList)
    
            self.add_event = threading.Event()
            def add_all(obj=self,wait=True):
                while wait and not obj.__initialized: 
                    obj.add_event.wait(.1)
                if obj.SubComposers:
                    obj.SubComposers = [s for s in obj.SubComposers if s]
                    print 'Adding devices from SubComposers list (%s)'%obj.SubComposers
                    obj.SubComposers = dict.fromkeys(obj.SubComposers)
                    for composer in obj.SubComposers:
                        print 'Adding devices from %s'%composer
                        if obj.add_event.is_set(): break
                        obj.SubComposers[composer] = {}
                        obj.AddDeviceToList(composer)
                        if wait: obj.add_event.wait(.1)
                print 'Adding devices from DevicesList(%s(%s))'%(type(self.DevicesList),self.DevicesList)
                for device in obj.DevicesList:
                    if obj.add_event.is_set(): break
                    obj.AddDeviceToList(device)
                    if wait: obj.add_event.wait(.1)
                print('Ready to process events ...')
                return
            if False:
                self.add_thread = threading.Thread(target=add_all)
                self.add_thread.setDaemon(False)#True)
                self.add_thread.start()
            else: add_all(wait=False)
            
        print('#'*80)        
        print('Ready to accept request ...')
        print('#'*80)        
        self.__initialized = True

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        #print "In ", self.get_name(), "::always_executed_hook()"
        self.debug("In ::always_executed_hook()")
        DynamicDS.always_executed_hook(self)
        if (self.LastStateCheck+5e-3*self.PollingCycle)<time.time():
            self.evaluateStates()
        else:
            self._locals['DEVICES'] = CaselessList(self.DevicesDict.keys())
            if self.SortLists: self._locals['DEVICES'] = sorted(self._locals['DEVICES'])
            self._locals['STATES'] = [self.DevicesDict[k] for k in self._locals['DEVICES']]

#==================================================================
#
#    PyStateComposer read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        #print "In ", self.get_name(), "::read_attr_hardware()"
        self.debug("In read_attr_hardware()")


#------------------------------------------------------------------
#    Read VersionNumber attribute
#------------------------------------------------------------------
    def read_VersionNumber(self, attr):
        self.debug( "In "+self.get_name()+"::read_VersionNumber()")

        #    Add your own code here
        attr_VersionNumber_read = __RELEASE__
        attr.set_value(attr_VersionNumber_read)


#------------------------------------------------------------------
#    Read StatesList attribute
#------------------------------------------------------------------
    def read_StatesList(self, attr):
        #print "In ", self.get_name(), "::read_StatesList()"
        self.debug("In read_StatesList()")
        
        #    Add your own code here
        
        attr_StatesList_read = []
        [attr_StatesList_read.append(str(v)) for k,v in self.DevicesDict.items()]
        if self.SubComposers:
            [[attr_StatesList_read.append(v) for k,v in sorted(self.SubComposers[c].items())] for c in sorted(self.SubComposers)]
        attr.set_value(attr_StatesList_read, len(attr_StatesList_read))


#------------------------------------------------------------------
#    Read DevicesList attribute
#------------------------------------------------------------------
    def read_DevicesList(self, attr):
        #print "In ", self.get_name(), "::read_DevicesList()"
        self.debug("In read_DevicesList")
        
        #    Add your own code here
        
        attr_DevicesList_read = []
        [attr_DevicesList_read.append(k) for k,v in self.DevicesDict.items()]
        if self.SortLists: attr_DevicesList_read = sorted(attr_DevicesList_read)
        if hasattr(self,'SubComposers') and self.SubComposers:
            [[attr_DevicesList_read.append(k) for k,v in sorted(self.SubComposers[c].items())] for c in sorted(self.SubComposers)] 
        attr.set_value(attr_DevicesList_read, len(attr_DevicesList_read))

#------------------------------------------------------------------
#    Read DevStates attribute
#------------------------------------------------------------------
    def read_DevStates(self, attr):
        #print "In ", self.get_name(), "::read_DevStates"
        self.debug("In read_DevStates")
        
        #    Add your own code here
        attr_DevStates_read = []
        if hasattr(self,'_locals'):
            devs,states = self._locals['DEVICES'],self._locals['STATES']
            for d,s in zip(devs,states):
                attr_DevStates_read.append(str(d))
                attr_DevStates_read.append(str(s))
        attr.set_value(attr_DevStates_read, len(attr_DevStates_read))


#==================================================================
#
#    PyStateComposer command methods
#
#==================================================================

#------------------------------------------------------------------
#    AddDevice command:
#
#    Description: 
#    argin:  DevString    Device to add to the composing
#------------------------------------------------------------------
    def AddDevice(self, argin):
        #print "In ", self.get_name(), "::AddDevice("+argin+")"
        self.debug("In AddDevice(%s)" % argin)
        
        #    Add your own code here
        self.AddDeviceToList(argin)


#------------------------------------------------------------------
#    RemoveDevice command:
#
#    Description: 
#    argin:  DevString    Device to remove
#------------------------------------------------------------------
    def RemoveDevice(self, argin):
        """ @deprecated RemoveDevice method has been deprecated """
        #print "In ", self.get_name(), "::RemoveDevice()"
        self.debug("In RemoveDevice(%s)" % argin)
        
        #    Add your own code here
        self.warning('THE REMOVE DEVICE METHOD IS OBSOLETE!!! ... REFACTOR IT!!!')
        return
    
        if '*' in argin or '?' in argin:
            devs = PyTango.Database().get_device_exported(argin)
            for d in devs:
                self.RemoveDevice(d)
        elif argin in self.Devices.keys():
            argin = argin.lower()
            self.Devices[argin].dp.unsubscribe_event(self.Devices[argin].event_id)
            self.Devices.pop(argin)
            print "\t",self.get_name(),"::RemoveDevice(",argin,"): device unsuscribed and removed from list!"
            self.evaluateStates()

#------------------------------------------------------------------
#    UpdateStatePolicy command:
#
#    Description: Updates the way State is computed
#    
#------------------------------------------------------------------
    def UpdateStatePolicy(self, read_properties = True):
        """
        It updates two Objects used to manage States:
        @li StatePriorities is the dictionary used
        @li StatePolicy is its string representation (Tango Property)
        """
        self.info("In UpdateStatePolicy()")
        
        #Updating Device Properties
        if read_properties: self.get_device_properties(self.get_device_class())
        #Updating StatePriorites dictionary from StatePolicy property
        if len(self.StatePolicy):
            self.StatePriorities = {}
            separators = ":=, "
            for line in self.StatePolicy:
                try:
                    line = line.strip().split('#')[0]
                    if not line: continue
                    state,priority = fun.first(line.split(s) for s in separators if s in line)
                    self.StatePriorities[state.upper()]=int(priority)
                except:
                    self.error('Exception in UpdateStatePolicy():\n%s'%traceback.format_exc())
            [self.StatePriorities.__setitem__(s,0) for s in self.TangoStates if s not in self.StatePriorities]
        else:
            self.info("Reloading default StatePolicy")
            self.StatePriorities = dict(PyStateComposer.defaultStatePriorities)
            
        #Updating StatePolicy from StateProperties dictionary
        self.StatePolicy = ['%s,%d'%(k,v) for v,k in sorted((j,s) for s,j in self.StatePriorities.items())]
        if read_properties: get_database().put_device_property(self.get_name(),{'StatePolicy':self.StatePolicy})
        self.info('StatePolicy set to: %s' % str(self.StatePolicy))
        return


#==================================================================
#
#    PyStateComposerClass class definition
#
#==================================================================
class PyStateComposerClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'DynamicAttributes':
            [PyTango.DevVarStringArray,
            "Attributes and formulas to create for this device.<br>This Tango Attributes will be generated dynamically using this syntax:<br>&nbsp;AllPressures=DevVarDoubleArray([XAttr(dev+'/Pressure') or 0 for dev in DEVICES])",
            [] ],
        'DynamicStates':
            [PyTango.DevVarStringArray,
            "This property will allow to declare new States dinamically based on dynamic attributes changes:<br>&nbsp;FAULT=any([s==FAULT for s in STATES])<br>&nbsp;ON=1",
            [] ],
        'DynamicStatus':
            [PyTango.DevVarStringArray,
            "Each line generated by this property code will be added to status",
            [] ],
        'CheckDependencies':
            [PyTango.DevBoolean,
            "This property manages if dependencies between attributes are used to check readability.",
            [False] ], #This property is normally True for other Dynamic Devices
        'PollingCycle':
            [PyTango.DevLong,
            "Default period for polling all device states.",
            [ 3000 ] ],
        'UseEvents':
            [PyTango.DevVarStringArray,
            "This property allows to enable/disable events management.",
            [ 'false' ] ],
        'DevicesList':
            [PyTango.DevVarStringArray,
            "A list of device names, wildcards like domain/family/* are allowed.<br>If this property is not initialized DeviceNameList is read instead.",
            [] ],
        'IgnoreList':
            [PyTango.DevVarStringArray,
            "A list of device names, wildcards like domain/family/* are allowed.<br>The devices in this list will not be used to compose the state.",
            [] ],    
        'SubComposers':
            [PyTango.DevVarStringArray,
            "A list of composer device names from which devices/states lists will be imported.",
            [] ],            
        'StatePolicy':
            [PyTango.DevVarStringArray,
            "A list of States and its priority. this property is not used if DynamicStates has been initialized.",
            [] ],
        'SortLists':
            [PyTango.DevBoolean,
            "A property to control whether DEVICES/STATES lists will be sorted or not",
            [True] ],
        'LogLevel':
            [PyTango.DevString,
            "This property selects the log level (DEBUG/INFO/WARNING/ERROR)",
            ['WARNING'] ],
        }


    #    Command definitions
    cmd_list = {
        'AddDevice':
            [[PyTango.DevString, "Device to add to the composing"],
            [PyTango.DevVoid, ""]],
        #'RemoveDevice':
            #[[PyTango.DevString, "Device to remove"],
            #[PyTango.DevVoid, ""]],
        'UpdateStatePolicy':
            [[PyTango.DevVoid, "Reloads StatePolicy from the database"],
            [PyTango.DevVoid, ""]],
        }


    #    Attribute definitions
    attr_list = {
        'VersionNumber':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'Display level':PyTango.DispLevel.EXPERT,
                'description':"Version number and release note",
            } ],
        'StatesList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 2048],
            {
                'description':"States of subscribed devices.",
            } ],
        'DevicesList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 2048],
            {
                'description':"Devices actually subscribed.",
            } ],
        'DevStates':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 2048],
            {
                'description':"A list with device/state pairs .",
            } ],            
        }


#------------------------------------------------------------------
#    PyStateComposerClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print "In PyStateComposerClass  constructor"

#==================================================================
#
#    PyStateComposer class main method
#
#==================================================================

PyStateComposer,PyStateComposerClass=FullTangoInheritance('PyStateComposer',PyStateComposer,PyStateComposerClass,DynamicDS,DynamicDSClass,ForceDevImpl=True)
PyStateComposer,PyStateComposerClass=FullTangoInheritance('PyStateComposer',PyStateComposer,PyStateComposerClass,Dev4Tango,PyTango.DeviceClass,ForceDevImpl=False)

def main():
    #@staticmethod
    #def main():
    try:
        py = ('PyUtil' in dir(PyTango) and PyTango.PyUtil or PyTango.Util)(sys.argv)
        py.add_TgClass(PyStateComposerClass,PyStateComposer,'PyStateComposer')        
        U = PyTango.Util.instance()
        CreateDynamicCommands(PyStateComposer,PyStateComposerClass)
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',traceback.format_exc()
    except Exception,e:
        print '-------> An unforeseen exception occured....',traceback.format_exc()    
        
    PyStateComposer.main()
    
if __name__ == '__main__':
    main()