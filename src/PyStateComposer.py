#    "$Name: not supported by cvs2svn $";
#    "$Header: /users/chaize/newsvn/cvsroot/Calculation/PyStateComposer/src/PyStateComposer.py,v 1.2 2009-01-22 16:37:41 sergi_rubio Exp $";
#=============================================================================
#
# file :        PyStateComposer.py
#
# description : Python source for the PyStateComposer and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PyStateComposer are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author: sergi_rubio $
#
# $Revision: 1.2 $
#
# $Log: not supported by cvs2svn $
# Revision 1.1.1.1  2007/10/17 16:42:52  sergi_rubio
# A PyTango StateComposer, based on Calculation/StateComposer device
#
# copyleft :    ALBA Synchrotron
#               Barcelona, EU
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Controls Section - ALBA
#=============================================================================
#


import PyTango
import sys
import os
import time
import traceback
import threading
import collections
from functools import partial
from copy import *
from PyTango_utils import dynamic,dicts
#from PyTango_utils import device #@warning importing PyTango_utils.device caused misbehaviours when closing the device server

"""
@mainpage @package PyStateComposer Tango Device Server

@attention Now is temporariliy disabled but in feature releases PyTango_utils.callbacks will be on charge of managing EventsList, EventReceivers, 
AttributesList, StatesList, EventStruct, EventCallback, GlobalCallback objects

This is because several PyTango device servers are sharing this features

@section Usage

The device server is configured using ...
"""

## AUXILIARY CLASSES:

class defaultdict_fromkey(collections.defaultdict):
    """ This class allows to create dictionaries with default values generated using the key value. """
    def __missing__(self, key):
        if self.default_factory is None: raise KeyError(key)
        self[key] = value = self.default_factory(key)
        return value

__lock__ = threading.RLock()
def __locked__(f,*args,**kwargs):
    """ decorator for secure-locked functions """
    try:
        __lock__.acquire()
        return f(*args,**kwargs)
    except Exception,e:
        print 'Exception in%s(*%s,**%s): %s' % (f.__name__,args,kwargs,e)
    finally:
        __lock__.release()
        
class TDev:
    """ This class keeps name,State,DeviceProxy and Event information for subscribed devices"""
    def __init__(self,name):
        self.name=name
        self.event_id=None
        self.proxy=None
        self.State=PyTango.DevState.UNKNOWN
        self.last_event = None
        self.last_success = 0
        self.next_update = time.time() #Even better ... the next epoch when this Dev should be read
        self.lock = threading.Lock()
    def __str__(self):
        return str(name)+","+str(self.event_id)+","+TangoStates[self.State]+";"

class forcedEvent(object):
    """ This class allows to simulate events within the device itself """
    def __init__(self,device,attr_name,attr_value,err,errors):
        self.device=device
        self.attr_name=attr_name
        self.attr_value=attr_value
        self.err=err
        self.errors=errors        


#==================================================================
#   PyStateComposer Class Description:
#
#
#==================================================================


#class PyStateComposer(PyTango.Device_3Impl):
class PyStateComposer(dynamic.DynamicDS):
#class PyStateComposer(device.Dev4Tango,dynamic.DynamicDS):
    '''   
    PyStateComposer is completely based on PyTango_utils.callbacks package:
    @li When a new Device is added the composer subscribes to its State changes.
    @li Device/State is added to callbacks.EventsList; and the composer is assigned to EventsList[Device/State].receivers list.
    @li The object callbacks.GlobalCallback receives all subscribed events and then distributes to registered receivers (PyStateComposer.push_event).
    @li callbacks.AttributesList and StatesList are caches of the last values received.
    
    @todo A not-event driven version of PyStateComposer must be developed ... to provide StateComposing even when notifd crashes
    @todo ThreadDict, ProxyDict and other new/style classes must be used instead of crashy devslist
    @todo get_subscribed_devices() could be used instead of DevicesList() at many points of the code?
    '''

    #--------- Add you global variables here --------------------------
    TangoStates = ['ON','OFF','CLOSE','OPEN','INSERT','EXTRACT','MOVING','STANDBY','FAULT','INIT','RUNNING','ALARM','DISABLE','UNKNOWN']
    
    def get_subscribed_devices(self):
        '''
        It returns a list with all devices managed by callbacks to which this Composer is effectively subscribed
        '''
        if not self.UseEvents: 
            self.warning('Events management is DISABLED!')
            return
        result = []
        name = self.get_name()
        for ev in EventsList.values():
            if name in ev.receivers:
                result.append (ev.dev_name)
        return result
    
    #@classmethod
    def read_remote_attribute(self,device,attribute,poll_cycle,devs_dict,bads_dict={}):
        """
        @param[in] poll_cycle must be specified in milliseconds!
        This method executes a read_attribute in a remote proxy.
        It verifies first with a ping() command if the device is working or not.
        The devices that does not answer in the expected time are tested with a bigger period.
        @todo In the future it will put more unresponsive devices in a separated read list (bads_dict)
        @todo could be TDev.lock.acquire(),release() calls necessary?
        @todo read_times for each attribute should be quantified and substracted from next polling_cycle waits. It would require adding some thread-safe methods to ThreadDict to be able to modify timewait values.
        """
        tdev = device in devs_dict and devs_dict[device] or device in bads_dict and bads_dict[device] or None
        poll_cycle_ms = (poll_cycle/1e3)
        now = time.time()
        #Device is not read until next_update is scheduled
        if now < tdev.next_update: 
            self.info('%s.%s will not be read until %s' % (device,attribute,time.ctime(tdev.next_update)))
            return tdev
        
        timeout = float(poll_cycle)/len(devs_dict if device in devs_dict else bads_dict if device in bads_dict else [1])
        if tdev:
            #tdev.lock.acquire()
            proxy = tdev.proxy
            #tdev.lock.release()
            try:
                proxy.set_timeout_millis(100)
                proxy.ping()
                try:
                    proxy.set_timeout_millis(int(timeout if now-tdev.last_success<3.*poll_cycle_ms else 3000))
                    old_state = tdev.State
                    tdev.State = proxy.state()
                    if tdev.State!=old_state:
                        self.info('%s State Changed! %s -> %s' % (device,old_state,tdev.State))
                    #if attribute.lower() != 'state':
                        #value = proxy.read_attribute(attribute).value
                    tdev.last_success = now
                    tdev.next_update = now + poll_cycle_ms
                    self.info('%s next update at %s + %s' % (device,time.ctime(now),poll_cycle_ms))
                    return tdev
                except Exception,e: #except PyTango.CommunicationFailed,e:
                    #state() failed ... something happenz with this device
                    self.error("%s exception in PyStateComposer.read_remote_attribute(%s,%s): %s" % (type(e),device,attribute,traceback.format_exc()))
                    tdev.next_update = now + 3.*poll_cycle_ms
                    return tdev
            except Exception,e: 
                #ping() failed ... probably the device is not running
                self.error("%s exception in PyStateComposer.read_remote_attribute(%s,%s).ping(): %s" % (type(e),device,attribute,traceback.format_exc()))
                tdev.State = PyTango.DevState.UNKNOWN
                tdev.next_update = now + 5.*poll_cycle_ms
                return tdev

    def evaluateStates(self):
        '''
        This method is called from push_event, always_executed_hook, AddDeviceToList and RemoveDevice methods; It depends of UseEvents property.
        
        It iterates over DevicesList/StatesList dictionary and:
        
        @li Chooses the highest priority in StatesList
        @li Makes a report with the epochs received for each dev in EventsList
        @li Makes a report with subscribed AttributesList
        @li Updates status and state and forces a push_change_event('state') 
        '''
        self.debug('In evaluateStates() ...')
        now = time.time()
        try:
            status = 'DevicesList:\n'
            old_state = self.get_state()
            # DevicesList is the list of devices
            # StatesList is a dictionary with Device:State pairs
            if self.UseEvents:
                #@todo It should be verified that this composer is subscribed to callbacks.StatesList devices
                StatesList = callbacks.StatesList.items() 
            else:
                StatesList = dict((k,d.State) for k,d in self.DevicesList.items())
            
            if not StatesList:
                self.set_state(PyTango.DevState.UNKNOWN)
                return
            result = StatesList.values()[0] #Initialized to first State
            
            for dev,state in StatesList.iteritems():
                #if self.get_name() not in e.receivers: 
                    #print 'in ',self.get_name(),'.evaluateStates(): called for other device?!'
                    #continue
                if self.StatePriorities[self.TangoStates[int(state)]]>self.StatePriorities[self.TangoStates[int(result)]]:
                    self.debug('evaluating '+dev+'; Priority of '+self.TangoStates[state]+','+state+' is higher than '+self.TangoStates[result]+','+result+'; STATE CHANGES!')
                    result=state
                status = status + dev + ':\t' + self.TangoStates[state]
                
                #@todo Status must be complemented with event-related information
                ##Getting When this value was updated for the last time
                #if EventsList[dev.lower()+'/state'].attr_value is not None:
                    #status = status +  '\t' + time.ctime(EventsList[dev.lower()+'/state'].attr_value.time.tv_sec)
                ##Getting something cryptic
                #if dev.lower() in callbacks.AttributesList.keys():
                    #status = status +  '\t' + str(callbacks.AttributesList[dev.lower()])
                    
                status = status + '\n'
                
            if result != old_state:
                #@todo Some Hystheresis or change conditions must be applied before changing the State @n (e.g. keeping FAULT at least for 5 State evaluations, waiting 3 cycles before setting an UNKNOWN state)
                self.info('State changed! %s -> %s' % (old_state,result))
                self.set_state(result)
                self.push_change_event('state')
                
            status = 'The PyStateComposer is in ' + self.TangoStates[self.get_state()] + ' State.\n' + status
            if not self.UseEvents: 
                status += '\nPollingThread Info:\n'
                status += 'timewait is %s ms\n' % (1000.*self.DevicesList.get_timewait())                
                status += 'last update at %s\n' % time.ctime(self.DevicesList.get_last_update())
            self.set_status(status)
            
        except Exception,e:
            self.error('Exception in evaluateStates(): %s' % traceback.format_exc())
            
        self.debug('Out of evaluateStates() ... it took %f ms' % (1000.*(time.time()-now)))

    def push_event(self,event):
        """ This method is executed each time a new event is received by the composer
        params[in] event : allows to extract all the information relative to the event produced.

        @par If UseEvents set to True:
        @li push_event method is also called from the GlobalCallback object; 
        @li GlobalCallback is a singletone instance of callbacks.EventCallback class;  
        @li GlobalCallback distributes each event to its EventsList[AttributeName].receivers
        """
        try:
            self.debug("In push_event(%s,%s)" % (event.device,event.attr_name))
            device,attr_name = event.device.lower(),event.attr_name.lower()
            value = event.attr_value.value if hasattr(event.attr_value,'value') else None
            isState = attr_name.endswith('/state')
            if not event.err and value is not None:
                self.debug("Event: %s,%s = %s" % (device,attr_name,value))
            else:
                self.warning("Received an Error Event!: %s" % event.errors)

            if self.UseEvents:
                callbacks.EventsList[attr_name].set(event)
                if isState: callbacks.StatesList[device] = value if not event.err else PyTango.DevState.UNKNOWN
                else: callbacks.AttributesList[device] = value
            elif device in self.DevicesList:
                self.DevicesList[device].last_event = event
                if isState: self.DevicesList[device].State = value

            self.evaluateStates()
        except Exception,e:
            self.error("Exception in push_event(): %" % traceback.format_exc())
   
    def AddDeviceToList(self,argin):
        ''' @brief This method adds a new device to @bPyTango_utils.callback@b dictionaries: StatesList, EventsList, AttributesLIst ...
        @param[in] argin : the device to add; it must be an string; it can contain '*' or '?' , but not regular expressions
        
        Behaviour:
        @li the composer and the device are both added to DevicesList (but composer itself cannot be added as device)
        @li A DeviceProxy is created for the device
        @li If needed: StatesList[dev_name] and AttributesList[dev_name] are initialized to UNKNOWN and None
        @li For State and each value in AttributesList keys it checks if appears in the list of attributes of the device
        
        For each cross-checked device attribute (or at least State attribute):
        @li if ForcePolling is set ... the polling of this attribute is forced
        @li A TAttr object is added to EventsList dictionary; it stores event receivers, DeviceProxy, event_id and more ...
        @li The composer is subscribed to the device attribute CHANGE events
        '''
        self.info("In AddDeviceToList(%s) ..." % str(argin))
        try:
            if '*' in argin or '?' in argin:
                devs = PyTango.Database().get_device_exported(argin)
                for d in devs:
                    self.AddDeviceToList(d)
            else:
                dev_name = argin.lower()
                if dev_name==self.get_name().lower():
                    self.warning("In AddDevice(): This device doesn't allow recursive composing.")
                else:
                    try:
                        #@todo devslist.DevicesList will keep information about all internal devices allocated or used inside a DeviceServer; composer and device must be added to that list
                        #@todo IT SHOULD BE CHECKED THAT A DEVICE PROXY DOESN'T EXIST BEFORE CREATING A NEW ONE!!!
                        dev = PyTango.DeviceProxy(argin)
                        try:
                            dev.ping()
                            #@todo Check for DynamicAttributes!     
                            #att = PyTango.AttributeProxy(att_name)                    
                            attrs = [ 'State' ] #+ callbacks.AttributesList #Be careful self.AttributesList != callbacks.AttributesList #... What are the values of this list!? ... names of devices!?!?!
                            if not self.UseEvents:
                                self.DevicesList[argin].lock.acquire()
                                self.DevicesList[argin].proxy = dev
                                self.DevicesList[argin].lock.release()
                                self.DevicesList.append(argin)                                
                            else:
                                # Initializing lists
                                if dev_name not in callbacks.StatesList: callbacks.StatesList[dev_name] = PyTango.DevState.UNKNOWN
                                if dev_name not in callbacks.AttributesList: callbacks.AttributesList[dev_name] = None
                                
                                for att in attrs:
                                    att_name = (dev_name+'/'+att).lower()
                                    if att not in dev.get_attribute_list():
                                        continue
                                    if not dev.is_attribute_polled(att) and self.ForcePolling:
                                        self.info('::AddDevice(): forcing %s polling to %s' % (att,argin))
                                        period = dev.get_attribute_poll_period(att) or 3000
                                        dev.poll_attribute(att,period)
                                        self.debug("%s.poll_attribute(%s,%s)" % (argin,att,period))
                                    #cb = self 
                                    cb = GlobalCallback
                                    
                                    if not att_name in callbacks.EventsList.keys():
                                        callbacks.EventsList[att_name] = self.TAttr(att_name)
                                        callbacks.EventsList[att_name].receivers.append(self.get_name())
                                        self.info('AddDevice: subscribing event for %s'  % att_name)
                                        event_id = dev.subscribe_event(att,PyTango.EventType.CHANGE,cb,[],True)
                                        # Global List
                                        callbacks.EventsList[att_name].dp = dev
                                        callbacks.EventsList[att_name].event_id = event_id
                                        callbacks.EventsList[att_name].dev_name = dev_name
                                        print "In ", self.get_name(), "::AddDevice()", ": Listing Device/Attributes in EventsList:"
                                        for a,t in callbacks.EventsList.items(): print "\tAttribute: ",a,"\tDevice: ",t.dev_name,"\n"
                                    else:
                                        self.warning("::AddDevice(%s): This attribute is already in the list, adding composer to receivers list." % att_name)
                                        if not dev_name in callbacks.EventsList[att_name].receivers:
                                            callbacks.EventsList[att_name].receivers.append(self.get_name())
                                        if callbacks.EventsList[att_name].attr_value is not None:
                                            if att is 'State':
                                                callbacks.StatesList[dev_name]=EventsList[att_name].attr_value.value
                                            else: 
                                                callbacks.AttributesList[dev_name]=EventsList[att_name].attr_value.value
                        except:
                            self.error('%s.ping() or attribute registering failed!!!' % dev.get_name())                                            
                    except:
                        self.error('Unable to create a DeviceProxy for %s' % argin)
                        
                    self.debug('listOfDevices(): %s' % str(self.get_subscribed_devices()))
                    self.evaluateStates()
        except Exception,e:
                self.error('Exception in AddDevice(): %s' % traceback.format_exc())


#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        self.call__init__(dynamic.DynamicDS,cl,name,_locals={},useDynStates=True)
        self.call__init__(PyTango.Device_3Impl,cl,name)
        PyStateComposer.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.info("[Device delete_device method] for device")
        self.DevicesList.stop()
        #if self.UseEvents:
            #for e,t in callbacks.EventsList.items():
                #t.dp.unsubscribe_event(t.event_id)
                #del EventsList[e]
                ##me = self.get_name()
                ##if me in t.receivers:


#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        print "In ", self.get_name(), "::init_device()"
        #print 'Members are : ','\n'.join(str(d) for d in dir(self))
        #multia = self.get_device_attr()
        #print str(dir(multia))
        #print str(dir(multia.get_attr_by_name('StateAttribute')))
        #print str(self.get_device_class().attr_list)
        
        self.set_state(PyTango.DevState.UNKNOWN)
        self.get_device_properties(self.get_device_class())
        self.setLogLevel(self.LogLevel if hasattr(self,'LogLevel') else 'DEBUG')
        
        print self.get_name(),": ",        " ... parsing properties ... "
        self.StatePriorities = { 
            'ON':0, 
            'OFF':11, 
            'CLOSE':10, 
            'OPEN':0, 
            'INSERT':10, 
            'EXTRACT':0, 
            'MOVING':8, 
            'STANDBY':0, 
            'FAULT':14, 
            'INIT':13, 
            'RUNNING':8, 
            'ALARM':13, 
            'DISABLE':11, 
            'UNKNOWN':12 
            }
        
        #@todo srubio: PyStateManager disabled! whole concept must be redefined or deprecated @n
        #This dict will keep the names and states of devices       
        self.DevicesList = dicts.DefaultThreadDict( 
            default_factory = lambda k: TDev(k), 
            timewait=.001*(self.PollingCycle/(1+len(self.DeviceNameList) or 1))
            )
        self.DevicesList.read_method = partial(self.read_remote_attribute,**{
            'devs_dict':self.DevicesList,
            'attribute':'state',
            'poll_cycle':self.PollingCycle,
            })
        #self.DevicesList.trace = True
        [self.AddDeviceToList(device) for device in self.DeviceNameList]
        
        #Enabling/Disabling EventsCallback
        if not hasattr(self,'UseEvents'): 
            self.UseEvents = False
        else: self.debug('UseEvents(%s) == %s' % (type(self.UseEvents),self.UseEvents))
        if self.UseEvents:
            from PyTango_utils import callbacks,devslist
        self.warning('Event Management has been %s.' % (self.UseEvents and 'ENABLED' or 'DISABLED'))
        
        #Updating StatePriorities dictionary
        self.UpdateStatePolicy(read_properties = False)
        
        self.info('Updating Device Properties ...')
        PyTango.Database().put_device_property(self.get_name(),{
            'StatePolicy':self.StatePolicy, \
            'DeviceNameList':self.DeviceNameList, \
            'UseEvents':[str(self.UseEvents)], \
            'AlwaysExecutedHook':self.AlwaysExecutedHook or [], \
            'PollingCycle':[self.PollingCycle], \
            })             #'AttributeName':self.AttributeName, \

        if self.UseEvents:
            self.set_change_event('State',True,True)
            
        self.DevicesList.start()
        self.info('Ready to accept request ...')
        


#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        #print "In ", self.get_name(), "::always_executed_hook()"
        self.debug("In ::always_executed_hook()")
        dynamic.DynamicDS.always_executed_hook(self)
        
        #This lines allow to use the AlwaysExecutedHook property to add custom code to the Device
        if self.AlwaysExecutedHook:
            code = ''
            for l in self.AlwaysExecutedHook:
                code = code+l+'\n'
            try:
                exec code
            except Exception,e:
                self.error('Exception in Custom AlwaysExecutedHook: %s' % traceback.format_exc())
                
        if not self.UseEvents:
            self.evaluateStates()


#==================================================================
#
#    PyStateComposer read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        #print "In ", self.get_name(), "::read_attr_hardware()"
        self.debug("In read_attr_hardware()")



#------------------------------------------------------------------
#    Read StatesList attribute
#------------------------------------------------------------------
    def read_StatesList(self, attr):
        #print "In ", self.get_name(), "::read_StatesList()"
        self.debug("In read_StatesList()")
        
        #    Add your own code here
        
        attr_StatesList_read = []
        if self.UseEvents:
            for v in callbacks.StatesList.values(): attr_StatesList_read.append(str(v))
        else:
            [attr_StatesList_read.append(v.State) for v in self.DevicesList.values()]
        attr.set_value(attr_StatesList_read, len(attr_StatesList_read))


#------------------------------------------------------------------
#    Read DevicesList attribute
#------------------------------------------------------------------
    def read_DevicesList(self, attr):
        #print "In ", self.get_name(), "::read_DevicesList()"
        self.debug("In read_DevicesList")
        
        #    Add your own code here
        
        attr_DevicesList_read = []
        if self.UseEvents:
            for d in callbacks.StatesList.keys(): attr_DevicesList_read.append(d)
        else:
            [attr_DevicesList_read.append(d) for d in self.DevicesList]
        attr.set_value(attr_DevicesList_read, len(attr_DevicesList_read))


#==================================================================
#
#    PyStateComposer command methods
#
#==================================================================

#------------------------------------------------------------------
#    AddDevice command:
#
#    Description: 
#    argin:  DevString    Device to add to the composing
#------------------------------------------------------------------
    def AddDevice(self, argin):
        #print "In ", self.get_name(), "::AddDevice("+argin+")"
        self.debug("In AddDevice(%s)" % argin)
        
        #    Add your own code here
        self.AddDeviceToList(argin)



#------------------------------------------------------------------
#    RemoveDevice command:
#
#    Description: 
#    argin:  DevString    Device to remove
#------------------------------------------------------------------
    def RemoveDevice(self, argin):
        """ @deprecated RemoveDevice method has been deprecated """
        #print "In ", self.get_name(), "::RemoveDevice()"
        self.debug("In RemoveDevice(%s)" % argin)
        
        #    Add your own code here
        self.warning('THE REMOVE DEVICE METHOD IS OBSOLETE!!! ... REFACTOR IT!!!')
        return
    
        if '*' in argin or '?' in argin:
            devs = PyTango.Database().get_device_exported(argin)
            for d in devs:
                self.RemoveDevice(d)
        elif argin in self.Devices.keys():
            argin = argin.lower()
            self.Devices[argin].dp.unsubscribe_event(self.Devices[argin].event_id)
            self.Devices.pop(argin)
            print "\t",self.get_name(),"::RemoveDevice(",argin,"): device unsuscribed and removed from list!"
            self.evaluateStates()



#------------------------------------------------------------------
#    UpdateStatePolicy command:
#
#    Description: Updates the way State is computed
#    
#------------------------------------------------------------------
    def UpdateStatePolicy(self, read_properties = True):
        """
        It updates two Objects used to manage States:
        @li StatePriorities is the dictionary used
        @li StatePolicy is its string representation (Tango Property)
        """
        self.info("In UpdateStatePolicy()")
        
        #Updating Device Properties
        if read_properties: self.get_device_properties(self.get_device_class())
        #Updating StatePriorites dictionaty from StatePolicy property
        if len(self.StatePolicy):
            separators = ":=, "
            tokens=[]
            for line in self.StatePolicy:
                for s in separators:
                    part=line.split(str(s))
                    if len(part)<2: 
                        continue
                    if part[1]!=None:
                        self.StatePriorities[part[0]]=part[1]
                        break
        #Updating StatePolicy from StateProperties dictionary
        self.StatePolicy = []
        for i in range(len(self.StatePriorities)):
            k = self.StatePriorities.keys()[i]
            self.StatePolicy.append(str(k)+","+str(self.StatePriorities[k]))    
        self.info('StatePolicy set to: %s' % str(self.StatePolicy))
        return


#==================================================================
#
#    PyStateComposerClass class definition
#
#==================================================================
#class PyStateComposerClass(PyTango.PyDeviceClass):
class PyStateComposerClass(dynamic.DynamicDSClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        #'PyStateManager':
            #[PyTango.DevString,
            #"Manager assigned to this Composer",
            #[] ],    
#        'AttributesList':
#            [PyTango.DevVarStringArray,
#            "Global Attribute",
#            [] ],
        'DynamicAttributes':
            [PyTango.DevVarStringArray,
            "Attributes and formulas to create for this device.\nThis Tango Attributes will be generated dynamically using this syntax:\nT3=int(Reg(7007)/10.)\nThe commands Coil, Flag, Reg and fReg will allow to declare \nDigital, Bit, Integer and Float variables respectively.",
            [] ],
        'DynamicStates':
            [PyTango.DevVarStringArray,
            "This property will allow to declare new States dinamically based on\ndynamic attributes changes. The function Attr will allow to use the\nvalue of attributes in formulas.\n\nALARM=Attr(T1)>70\nOK=1",
            [] ],
        'ForcePolling':
            [PyTango.DevBoolean,
            "To force or not attribute polling on target devices.",
            [ True ] ],
        'PollingCycle':
            [PyTango.DevLong,
            "Default period for polling all device states.",
            [ 3000 ] ],            
        'UseEvents':
            [PyTango.DevBoolean,
            "This property allows to enable/disable events management.",
            [ False ] ],
        'DeviceNameList':
            [PyTango.DevVarStringArray,
            "A list of device names, wildcards like domain/family/* are allowed.",
            [] ],
        'StatePolicy':
            [PyTango.DevVarStringArray,
            "",
            [] ],
        'AlwaysExecutedHook':
            [PyTango.DevVarStringArray,
            "Python Code to be executed before each command execution",
            [] ],
        }


    #    Command definitions
    cmd_list = {
        'AddDevice':
            [[PyTango.DevString, "Device to add to the composing"],
            [PyTango.DevVoid, ""]],
        'RemoveDevice':
            [[PyTango.DevString, "Device to remove"],
            [PyTango.DevVoid, ""]],
        'UpdateStatePolicy':
            [[PyTango.DevVoid, "Updates the way State is computed"],
            [PyTango.DevVoid, "Updates the way State is computed"]],
        }


    #    Attribute definitions
    attr_list = {
        'StatesList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 256],
            {
                'description':"States of subscribed devices.",
            } ],
        'DevicesList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 256],
            {
                'description':"Devices actually subscribed.",
            } ],
        }


#------------------------------------------------------------------
#    PyStateComposerClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.PyDeviceClass.__init__(self, name)
        self.set_type(name);
        print "In PyStateComposerClass  constructor"

#==================================================================
#
#    PyStateComposer class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.PyUtil(sys.argv)
        py.add_TgClass(PyStateComposerClass,PyStateComposer,'PyStateComposer')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print' an unforeseen exception occured: ',str(e)